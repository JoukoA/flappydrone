<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Drone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        canvas {
            display: block;
            background-image: url('flappydrone_background.png');
            background-size: cover;
            background-repeat: repeat-x;
            background-position: 0 0;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .message-box {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 1rem;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
        }
        .btn-restart {
            background-color: #10B981; /* Emerald green */
            transition: all 0.2s ease-in-out;
            transform: translateY(0);
        }
        .btn-restart:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            filter: brightness(1.1);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="flex flex-col items-center justify-center space-y-4 max-w-lg w-full">
        <h1 class="text-4xl font-bold text-gray-800 tracking-tight">Flappy Drone</h1>
        <div id="game-container" class="relative w-full aspect-[3/4]">
            <canvas id="gameCanvas" class="w-full h-full"></canvas>

            <!-- Game over and start message box -->
            <div id="messageContainer" class="absolute inset-0 flex items-center justify-center z-10">
                <div id="messageBox" class="message-box space-y-4 hidden">
                    <h2 class="text-3xl font-bold" id="messageTitle">Game Over!</h2>
                    <p class="text-xl font-semibold text-gray-700" id="finalScore"></p>
                    <button id="restartButton" class="btn-restart text-white font-bold py-3 px-6 rounded-full shadow-lg">
                        Restart Mission
                    </button>
                </div>
            </div>

            <!-- Start screen -->
            <div id="startScreen" class="absolute inset-0 flex items-center justify-center z-20">
                <img id="startImage" src="flappydrone_start.png" alt="Flappy Drone Start Screen" class="w-full h-full object-cover rounded-lg">
            </div>

            <!-- In-game score and lives display -->
            <div id="gameUI" class="absolute inset-x-0 top-4 flex justify-between items-center px-4 z-20 hidden">
                <div id="livesDisplay" class="flex space-x-2">
                    <div id="life1" class="w-8 h-8 flex items-center justify-center">
                        <svg viewBox="0 0 48 16" fill="currentColor" class="w-full h-full text-gray-700">
                            <rect x="16" y="4" width="16" height="8" rx="2"></rect>
                            <rect x="10" y="0" width="4" height="4" rx="1"></rect>
                            <rect x="34" y="0" width="4" height="4" rx="1"></rect>
                            <rect x="10" y="12" width="4" height="4" rx="1"></rect>
                            <rect x="34" y="12" width="4" height="4" rx="1"></rect>
                        </svg>
                    </div>
                    <div id="life2" class="w-8 h-8 flex items-center justify-center">
                        <svg viewBox="0 0 48 16" fill="currentColor" class="w-full h-full text-gray-700">
                            <rect x="16" y="4" width="16" height="8" rx="2"></rect>
                            <rect x="10" y="0" width="4" height="4" rx="1"></rect>
                            <rect x="34" y="0" width="4" height="4" rx="1"></rect>
                            <rect x="10" y="12" width="4" height="4" rx="1"></rect>
                            <rect x="34" y="12" width="4" height="4" rx="1"></rect>
                        </svg>
                    </div>
                    <div id="life3" class="w-8 h-8 flex items-center justify-center">
                        <svg viewBox="0 0 48 16" fill="currentColor" class="w-full h-full text-gray-700">
                            <rect x="16" y="4" width="16" height="8" rx="2"></rect>
                            <rect x="10" y="0" width="4" height="4" rx="1"></rect>
                            <rect x="34" y="0" width="4" height="4" rx="1"></rect>
                            <rect x="10" y="12" width="4" height="4" rx="1"></rect>
                            <rect x="34" y="12" width="4" height="4" rx="1"></rect>
                        </svg>
                    </div>
                </div>
                <div class="text-2xl font-extrabold text-white text-shadow-lg">
                    Emissions measured: <span id="currentScore">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- Game Variables and Constants ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            const messageContainer = document.getElementById('messageContainer');
            const messageBox = document.getElementById('messageBox');
            const messageTitle = document.getElementById('messageTitle');
            const finalScore = document.getElementById('finalScore');
            const restartButton = document.getElementById('restartButton');
            const livesDisplay = document.getElementById('livesDisplay');
            const currentScoreDisplay = document.getElementById('currentScore');
            const startScreen = document.getElementById('startScreen');
            const gameUI = document.getElementById('gameUI');

            const DRONE_WIDTH = 60;
            const DRONE_HEIGHT = 20;
            const DRONE_FLAP = -4;
            const GRAVITY = 0.2;
            const OBSTACLE_SPEED = 1.5;
            const GAP_SIZE = 150;
            const OBSTACLE_WIDTH = 50;
            const MAX_LIVES = 3;

            let drone = {};
            let score = 0;
            let obstacles = [];
            let smokeParticles = [];
            let isGameOver = false;
            let animationFrameId = null;
            let backgroundX = 0;
            let isGameStarted = false;
            let lives = MAX_LIVES;
            let frameCounter = 0;

            const backgroundMusic = new Audio('flappydrone_background.mp3');
            backgroundMusic.loop = true;

            const hitSound = new Audio('drone_hit.mp3');
            hitSound.volume = 0.3;

            // --- Game Functions ---

            // Initialize or reset the game state
            function init() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                startScreen.classList.add('hidden');
                gameUI.classList.remove('hidden');

                drone = {
                    x: 50,
                    y: canvas.height / 2,
                    velocity: 0,
                    rotorSpin: 0 // Keep rotor spin for the pixel drone animation
                };
                score = 0;
                lives = MAX_LIVES;
                obstacles = [];
                smokeParticles = [];
                isGameOver = false;
                backgroundX = 0;
                messageContainer.classList.add('hidden');
                currentScoreDisplay.textContent = '0';
                updateLivesDisplay();

                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                animate();
            }

            // Update the visual display of remaining lives
            function updateLivesDisplay() {
                for (let i = 1; i <= MAX_LIVES; i++) {
                    const lifeElement = document.getElementById(`life${i}`);
                    if (lifeElement) {
                        lifeElement.style.display = i <= lives ? 'flex' : 'none';
                    }
                }
            }

            // Draw the pixel-style drone on the canvas
            function drawDrone() {
                ctx.save();
                ctx.translate(drone.x, drone.y);

                // Draw the drone's body using pixel blocks
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(-12, -6, 24, 12);
                ctx.fillStyle = '#666666';
                ctx.fillRect(-10, -4, 20, 8);
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-3, -2, 6, 4);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-1, -1, 2, 2);

                // Draw the landing gear/feet
                ctx.fillStyle = '#333333';
                ctx.fillRect(-8, 6, 2, 4);
                ctx.fillRect(6, 6, 2, 4);

                // Draw the arms
                ctx.fillStyle = '#555555';
                ctx.fillRect(-16, -8, 8, 2);
                ctx.fillRect(8, -8, 8, 2);
                ctx.fillRect(-16, 6, 8, 2);
                ctx.fillRect(8, 6, 8, 2);

                const rotorPositions = [
                    {x: -12, y: -7}, {x: 12, y: -7},
                    {x: -12, y: 7}, {x: 12, y: 7}
                ];

                // Update rotor spin for animation
                drone.rotorSpin += 0.8;

                // Draw the rotating rotors
                rotorPositions.forEach((pos, i) => {
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(-2, -2, 4, 4);
                    ctx.strokeStyle = 'rgba(85, 85, 85, 0.6)';
                    ctx.lineWidth = 2;

                    const angle = drone.rotorSpin + (i * Math.PI / 2);

                    for (let j = 0; j < 4; j++) {
                        ctx.save();
                        ctx.rotate(angle + (j * Math.PI / 2));
                        ctx.beginPath();
                        ctx.moveTo(-6, 0);
                        ctx.lineTo(6, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.restore();
                });

                ctx.restore();
            }

            // Draw a single smokestack (top or bottom)
            function drawObstacle(x, y, width, height, isTop) {
                const baseColor = '#374151';
                const shadowColor = '#1f2937';
                const sideShadowWidth = 8;
                const topShadowHeight = 5;

                ctx.fillStyle = baseColor;
                ctx.beginPath();
                ctx.rect(x, y, width, height);
                ctx.fill();

                ctx.fillStyle = shadowColor;
                ctx.beginPath();
                ctx.rect(x + width - sideShadowWidth, y, sideShadowWidth, height);
                ctx.fill();

                if (isTop) {
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    ctx.rect(x, height - topShadowHeight, width, topShadowHeight);
                    ctx.fill();
                } else {
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    ctx.rect(x, y, width, topShadowHeight);
                    ctx.fill();
                }
            }

            // Draw smoke particles
            function drawSmoke() {
                for (let i = 0; i < smokeParticles.length; i++) {
                    const particle = smokeParticles[i];
                    ctx.fillStyle = `rgba(80, 80, 80, ${particle.opacity})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Generate a new pair of smokestacks
            function generateObstacle() {
                const minHeight = 50;
                const maxHeight = canvas.height - GAP_SIZE - minHeight;
                const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;

                obstacles.push({
                    x: canvas.width,
                    topY: 0,
                    topHeight: topHeight,
                    bottomY: topHeight + GAP_SIZE,
                    bottomHeight: canvas.height - topHeight - GAP_SIZE,
                    passed: false
                });
            }

            // Game loop
            function animate() {
                if (isGameOver || !isGameStarted) {
                    return;
                }

                frameCounter++;

                drone.velocity += GRAVITY;
                drone.y += drone.velocity;

                if (obstacles.length > 0) {
                    for (let i = 0; i < obstacles.length; i++) {
                        let obs = obstacles[i];
                        obs.x -= OBSTACLE_SPEED;

                        if (frameCounter % 15 === 0) {
                            smokeParticles.push({
                                x: obs.x + OBSTACLE_WIDTH / 2,
                                y: obs.bottomY,
                                size: Math.random() * 5 + 3,
                                opacity: 0.5,
                                velocityX: -OBSTACLE_SPEED + (Math.random() - 0.5) * 0.5,
                                velocityY: -0.5 - Math.random() * 0.5
                            });
                        }

                        if (
                            drone.x + DRONE_WIDTH > obs.x && drone.x < obs.x + OBSTACLE_WIDTH &&
                            (drone.y < obs.topHeight || drone.y > obs.bottomY)
                        ) {
                            handleCollision();
                            return;
                        }

                        if (!obs.passed && drone.x > obs.x + OBSTACLE_WIDTH) {
                            obs.passed = true;
                            score++;
                            currentScoreDisplay.textContent = score;
                        }
                    }

                    if (obstacles[0].x + OBSTACLE_WIDTH < 0) {
                        obstacles.shift();
                    }
                }

                for (let i = smokeParticles.length - 1; i >= 0; i--) {
                    const particle = smokeParticles[i];
                    particle.x += particle.velocityX;
                    particle.y += particle.velocityY;
                    particle.opacity -= 0.01;
                    particle.size += 0.2;

                    if (particle.opacity <= 0) {
                        smokeParticles.splice(i, 1);
                    }
                }

                if (drone.y + DRONE_HEIGHT / 2 > canvas.height || drone.y - DRONE_HEIGHT / 2 < 0) {
                    handleCollision();
                    return;
                }

                if (obstacles.length === 0 || canvas.width - obstacles[obstacles.length - 1].x > 200) {
                    generateObstacle();
                }

                backgroundX -= OBSTACLE_SPEED / 2;
                canvas.style.backgroundPosition = `${backgroundX}px 0`;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawSmoke();
                obstacles.forEach(obs => {
                    drawObstacle(obs.x, obs.topY, OBSTACLE_WIDTH, obs.topHeight, true);
                    drawObstacle(obs.x, obs.bottomY, OBSTACLE_WIDTH, obs.bottomHeight, false);
                });
                drawDrone();

                animationFrameId = requestAnimationFrame(animate);
            }

            // Handle a collision event (losing a life)
            function handleCollision() {
                lives--;
                updateLivesDisplay();

                hitSound.currentTime = 0;
                hitSound.play();

                if (lives <= 0) {
                    gameOver();
                } else {
                    drone.y = canvas.height / 2;
                    drone.velocity = 0;
                    obstacles = [];
                    animate();
                }
            }

            // Game over state
            function gameOver() {
                isGameOver = true;
                isGameStarted = false;
                cancelAnimationFrame(animationFrameId);
                backgroundMusic.pause();
                messageContainer.classList.remove('hidden');
                messageTitle.textContent = "Mission Failed! Drone Down!";
                finalScore.textContent = `Emissions measured: ${score}`;
                messageBox.classList.remove('hidden');
            }

            // Function to handle game start
            function startGame() {
                if (!isGameStarted) {
                    isGameStarted = true;
                    init();
                    backgroundMusic.currentTime = 0;
                    backgroundMusic.play();
                }
            }

            // Event listeners
            canvas.addEventListener('mousedown', function() {
                if (!isGameOver && isGameStarted) {
                    drone.velocity = DRONE_FLAP;
                }
            });

            // Touch support for mobile devices
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (!isGameOver && isGameStarted) {
                    drone.velocity = DRONE_FLAP;
                }
            });

            restartButton.addEventListener('click', startGame);

            // Handle start screen interaction
            startScreen.addEventListener('click', startGame);

            // Handle window resizing
            window.addEventListener('resize', function() {
                init();
            });

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        };
    </script>
</body>
</html>
